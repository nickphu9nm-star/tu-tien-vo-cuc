import React, { useRef, useEffect } from 'react';

interface BossCanvasProps { type: 'low' | 'mid' | 'high'; }

const BossCanvas: React.FC<BossCanvasProps> = ({ type }) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    const canvas = canvasRef.current; if (!canvas) return;
    const ctx = canvas.getContext('2d'); if (!ctx) return;
    let animationFrameId: number; let time = 0;
    const width = 200; const height = 200; const scale = 2;
    canvas.width = width * scale; canvas.height = height * scale; ctx.scale(scale, scale);

    const render = () => {
      time += 0.05; ctx.clearRect(0, 0, width, height);
      const cx = width / 2; const cy = height / 2; ctx.save();
      
      if (type === 'low') {
        ctx.translate(cx, cy + Math.sin(time * 2) * 5);
        ctx.fillStyle = "#064e3b"; ctx.strokeStyle = "#34d399"; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(0, 20); ctx.lineTo(-20, -10); ctx.lineTo(-40, -40); ctx.lineTo(-15, -30); ctx.lineTo(0, -20); ctx.lineTo(15, -30); ctx.lineTo(40, -40); ctx.lineTo(20, -10); ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.fillStyle = "#ff0000"; ctx.beginPath(); ctx.arc(-15, -15, 3, 0, Math.PI*2); ctx.arc(15, -15, 3, 0, Math.PI*2); ctx.fill();
        ctx.globalCompositeOperation = 'destination-over'; ctx.beginPath(); ctx.arc(0, 0, 60 + Math.sin(time * 3) * 5, 0, Math.PI * 2); ctx.fillStyle = "rgba(16, 185, 129, 0.2)"; ctx.fill();
      } else if (type === 'mid') {
        ctx.translate(cx, cy + Math.cos(time) * 3);
        for(let i=0; i<8; i++) { const angle = (time+i)*(Math.PI/4); const dist = 50+Math.sin(time*2+i)*10; ctx.beginPath(); ctx.arc(Math.cos(angle)*dist, Math.sin(angle)*dist, 8, 0, Math.PI*2); ctx.fillStyle = `rgba(255, ${100+i*20}, 0, 0.6)`; ctx.fill(); }
        ctx.fillStyle = "#7c2d12"; ctx.strokeStyle = "#f97316"; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(0, 40); ctx.quadraticCurveTo(-30, 10, -40, -20); ctx.lineTo(-10, -50); ctx.lineTo(0, -30); ctx.lineTo(10, -50); ctx.lineTo(40, -20); ctx.quadraticCurveTo(30, 10, 0, 40); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.arc(0, 0, 15 + Math.sin(time * 5) * 2, 0, Math.PI * 2); ctx.fillStyle = "#fbbf24"; ctx.fill();
      } else {
        ctx.translate(cx, cy); ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
        for(let i=0; i<12; i++) { const angle = (i/12)*Math.PI*2+time*0.5; const len = 70+Math.random()*10; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(Math.cos(angle-0.1)*30, Math.sin(angle-0.1)*30); ctx.lineTo(Math.cos(angle)*len, Math.sin(angle)*len); ctx.lineTo(Math.cos(angle+0.1)*30, Math.sin(angle+0.1)*30); ctx.fill(); }
        ctx.fillStyle = "#1a0b0b"; ctx.strokeStyle = "#ef4444"; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(0, 50); ctx.bezierCurveTo(-30, 40, -50, 0, -40, -40); ctx.lineTo(-20, -30); ctx.lineTo(0, -60); ctx.lineTo(20, -30); ctx.lineTo(40, -40); ctx.bezierCurveTo(50, 0, 30, 40, 0, 50); ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.shadowBlur = 10; ctx.shadowColor = "#ff0000"; ctx.fillStyle = "#ffffff";
        ctx.beginPath(); ctx.moveTo(-15, -10); ctx.lineTo(-25, -20); ctx.lineTo(-10, -20); ctx.fill(); ctx.beginPath(); ctx.moveTo(15, -10); ctx.lineTo(25, -20); ctx.lineTo(10, -20); ctx.fill(); ctx.shadowBlur = 0;
      }
      ctx.restore(); animationFrameId = requestAnimationFrame(render);
    };
    render(); return () => cancelAnimationFrame(animationFrameId);
  }, [type]);

  return (<div className="w-full h-48 flex items-center justify-center"><canvas ref={canvasRef} style={{ width: 200, height: 200 }} /></div>);
};
export default BossCanvas;